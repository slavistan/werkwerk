#!/usr/bin/env zsh

### Settings

# RE to enfore sane path names to keep the script simple. Applies to workspace
# template directories and their subdirectories. Usage along the lines of
# grep -q "$PATH_RE" && { _err "Invalid Path."; }
PATH_RE=':\|\s'

# File in every workspace template directory containing template specific
# initialization logic.
WS_SETUP='_setup.sh'


### Helpers

MYNAME=${0:A:t}
_err() {
  echo "$@" >&2;
}
_isabspath() {
  if [ "$1" = "-h" ]; then
    echo "Usage: $0 PATH

        \r  Returns 0 iff PATH is an absolute path. PATH need not necessarily exist."
    return
  fi

  echo "$1" | grep -q '^/' # Silly, I know ...
}
_no_common_lines() {
  if [ "$1" = "-h" ]; then
    echo "Usage: $0 STR1 STR2

        \r Returns 0 if strings STR1 and STR2 do not have any lines in common,
        \r 1 otherwise."
    return
  fi

  if [ $(comm -12 <( echo "$1" | sort ) <( echo "$2" | sort ) | wc -l) -eq 0 ]; then
    return 0
  fi
  return 1
}


### Core functionality

_usage() {
  echo "Usage: $MYNAME [OPTION...]

      \r  -f | --force          - Overwrite existing files
      \r  -i | --interactive    - Choose workspace interactively
      \r  -w | --workspace PATH - Full path to workspace directory
      \r  -o |
    "
}
_ls() {
  if [ "$1" = "-h" ]; then
    echo "Usage: $0

        \r  List all workspace templates. By default, displays all subdirectories found
        \r  in '/usr/share/werkwerk/', '/usr/local/share/werkwerk/' and
        \r  '~/.local/share/werkwerk/'. To include additional template directories add
        \r  their paths to '~/.config/werkwerk/werkwerkrc', one path per line. Empty
        \r  lines and lines starting with '#' are ignored.

        \r  '~' in paths found in werkwerkrc are translated to the corresponding HOMEs.
        \r  Environment variables in the paths do not work yet."
    return
  fi

  [ "$1" = "-l" ] && { shift; list_all=1; }

  # Build \n-sep'd list of workspace template directories
  wwpaths=""
  for wwpath in /usr/share/werkwerk/ /usr/local/share/werkwerk ~/.local/share/werkwerk; do
    [ -d "$wwpath" ] && wwpaths+="$wwpath\n"
  done
  if [ -f ~/.config/werkwerk/werkwerkrc ]; then
    cat ~/.config/werkwerk/werkwerkrc | while read line; do
      echo "$line" | grep -q '^#\|^\s*$' && continue
      # filter proper paths
      # TODO(feat): Shell-expand lines from werkwerkrc to allow for envvars.
      line=$(echo "$line" | sed 's:~:'"$HOME"':g')
      echo "$line" | grep -q "$PATH_RE" && { _err "Ignoring invalid path '$line'."; continue; }
      [ ! -d "$line" ] && { _err "Ignoring non-existent path '$line'."; continue; }
      wwpaths+="$line\n"
    done
  fi
  wwpaths=$(echo "$wwpaths" | grep -v '^$' | sort | uniq)

  # List all the template directories' subdirectories and enforce simple naming
  # rules (no whitespaces, no colons) in order to keep parsing simple.
  echo "$wwpaths" | while read wwpath; do
    find "$wwpath" -maxdepth 1 -mindepth 1 -type d | while read line; do
      echo "$line" | grep -q "$PATH_RE" && { _err "Ignoring invalid path '$line'."; continue; }
      if [  "$list_all" -eq 1 ]; then
        { echo "$line"
          head -1 "$line/$WS_SETUP" 2>/dev/null || echo "No description found." } |
        paste -d ':' - -
      else
        echo "$line"
      fi
    done
  done | column -s ':' -t
}
_cp() {
  if [ "$1" = "-h" ]; then
    echo "Usage: $0 [-f] TEMPLATE TARGET

        \r  Copy files from template to target directory. By default, existing files
        \r  in the target directory are not overwritten and the copy is rejected
        \r  as a whole if existing filenames collide. Use the '-f' flag to force
        \r  overwriting existing files.

        \r  Every file in the template directory is copied except for the '$WS_SETUP'
        \r  where it exists. 'TEMPLATE' and 'TARGET' must be absolute paths. 'TARGET'
        \r  will be created if it does not exist."
    return
  fi

  # parse opts
  [ "$1" = "-f" ] && { shift; force=1; }

  # health check
  _isabspath "$1" || { _err "TEMPLATE '$1' is not an absolute path."; return 1; }
  _ls | grep -q -F "$1" || { _err "TEMPLATE '$1' is not among the templates."; return 1; }
  _isabspath "$2" || { _err "TARGET '$2' is not an absolute path."; return 1; }

  # create target directory, if it does not exist
  mkdir -p "$2"

  # check for file collisions and abort
  if [ ! "$force" -eq 1 ]; then
    tocopy="$(find "$1" -mindepth 1 -type f -printf '%P\n')"
    existing="$(find "$2" -mindepth 1 -type f -printf '%P\n')"
    if ! _no_common_lines "$tocopy" "$existing"; then
      _err "Won't overwrite existing files. Abort."
      return 1
    fi
  fi

  cp -rf "$1"/* "$2"
}
_startup() {
  if [ "$1" = "-h" ]; then
    echo "Usage: $0 [-s STAGES] TEMPLATE TARGET

        \r  Execute startup stages for workspace template TEMPLATE in target directory
        \r  TARGET: If the workspace template contains a file name '$WC_SETUP', the
        \r  file is shell-executed inside the target directory for every value in the
        \r  comma-sep'd STAGES list, which is passed as argument. By default, STAGES
        \r  is '1,2'. '-s ""' results in no execution of '$WC_SETUP'.

        \r  Example: The default '$0 -s 1,2 \$TEMPLATE \$TARGET' will execute
        \r           > ( cd \$TARGET; sh \$TEMPLATE/$WS_SETUP 1; )
        \r           > ( cd \$TARGET; sh \$TEMPLATE/$WS_SETUP 2; )"
    return
  fi

  # parse opts & sanity check
  [ "$1" = "-s" ] && { stages="$2"; shift 2 } || stages="1,2"

  # health check
  _isabspath "$1" || { _err "TEMPLATE '$1' is not an absolute path."; return 1; }
  _ls | grep -q -F "$1" || { _err "TEMPLATE '$1' is not among the templates."; return 1; }
  _isabspath "$2" || { _err "TARGET '$2' is not an absolute path."; return 1; }

  if ls "$1/$WS_SETUP" >/dev/null 2>&1; then
    echo "$stages" | tr ',' '\n' | while read arg; do
      [ "$stages" = "" ] && continue
      ( cd $2; sh $1/$WS_SETUP $arg; )
    done
  fi
}
_interactive() {
  if [ "$1" = "-h" ]; then
    echo "Usage: $0

        \r  Let user choose a workspace template from a dmenu selection."
    return
  fi

  _ls -l | dmenu -l 15 -i -p 'Select template: ' | cut -d ' ' -f 1 ||
    { _err 'Aborted by user.'; return 1; }
}

case "$1" in
  -h|--help) _usage ;;
  ls) shift; _ls "$@" ;;
  @) shift; "$@" ;;
  *)
    local -a stages; stages=( -s "1,2" )
    local -a template; template=( -t )
    local -a flags; flags=( )
    local -a target; target=( -g )
    zparseopts -K -- t:=template s:=stages f=flags g:=target || return 1
    if [ "$template[2]" = "" ]; then
      template[2]=$(_interactive) || return 1
    fi
    if [ "$target[2]" = "" ]; then
      target[2]=$(mktemp -d -t "${MYNAME}_XXXXXX")
    fi
    echo "stages = '$stages[2]'"
    echo "flags = '$flags'"
    echo "template = '$template[2]'"
    echo "target = '$target[2]'"

    { [[ "$flags" =~ 'f' ]] && _cp -f "$template[2]" "$target[2]" || _cp "$template[2]" "$target[2]" } &&
    { _startup -s "$stages[2]" "$template[2]" "$target[2]" }
    ;;
esac
